# kt_codegen.py
# c++ code generator for the kt interpreter - generates and compiles c++ code from the program facet generated by kt_compiler.py
# (C) 2010 Mark Frohnmayer.  The use of this code is governed by its license.  See /license/info.txt in the source distribution for the full license agreement.

from kt_compiler import build_jump_table
from kt_vm import *
import types
import subprocess

class code_generator:
	def __init__(self, compiled_facet):
		self.depth = 0
		self.emit_table = build_jump_table(code_generator, "_emit_")
		self.facet = compiled_facet
		self.ip = 0
		self.operator_table = { "add" : "+", "subtract" : "-", "multiply" : "*", "divide" : "/", "modulus" : "%", "compare_less" : "<", "compare_greater" : ">", "compare_less_or_equal" : "<=", "compare_greater_or_equal" : ">=", "compare_equal" : "==", "compare_not_equal" : "!=", "logical_and" : "&&", "logical_or" : "||" }
		self.assign_operator_table = { "add" : "+=", "subtract" : "-=", "multiply" : "*=", "divide" : "/=", "modulus" : "%=" }
	
	def emit_statement(self, record, index):
		instruction = record.statements[index]
		if instruction[0] in self.emit_table:
			return self.emit_table[instruction[0]](self, record, *instruction[1:])
		else:
			return "\t\t\tunhandled-statement-" + instruction[0] + "();\n"
	
	def _emit_eval(self, record, expression):
		return "\t\t\t" + self.emit_expression(record, expression) + ";\n"
	
	def _emit_branch_if_zero(self, record, branch_target, test_expression):
		return "\t\t\tif(!(" + self.emit_expression(record, test_expression) + "))\n\t\t\t\tgoto label" + str(record.branch_targets[branch_target]) + ";\n"
	
	def _emit_branch_if_nonzero(self, record, branch_target, test_expression):
		return "\t\t\tif(" + self.emit_expression(record, test_expression) + ")\n\t\t\t\tgoto label" + str(record.branch_targets[branch_target]) + ";\n"

	def _emit_branch_always(self, record, branch_target):
		return "\t\t\tgoto label" + str(record.branch_targets[branch_target]) + ";\n"

	def _emit_return(self, record, expression_list):
		list_len = len(expression_list)
		if not list_len:
			return "\t\t\treturn;\n"
		elif list_len == 1:
			return "\t\t\treturn " + self.emit_expression(record, expression_list[0]) + ";\n"
		else:
			return "\t\t\treturn kt_create_array(" + ", ".join(self.emit_expression(record, x) for x in expression_list) + ");\n"

	def emit_expression(self, record, expression):
		node = expression[0]
		if node in self.emit_table:
			return self.emit_table[node](self, record, *expression[1:])
		else:
			return "unhandled-expression-" + node
	
	def _emit_assign(self, record, left, right):
		return self.emit_expression(record, left) + " = " + self.emit_expression(record, right)
	
	def _emit_float_assign(self, record, op, left, right):
		return self.emit_expression(record, left) + " " + self.assign_operator_table[op] + " " + self.emit_expression(record, right)

	def _emit_bool_binary(self, record, op, left, right):
		return self.emit_expression(record, left) + " " + self.operator_table[op] + " " + self.emit_expression(record, right)
	
	def _emit_float_binary(self, record, op, left, right):
		return self.emit_expression(record, left) + " " + self.operator_table[op] + " " + self.emit_expression(record, right)

	def _emit_local(self, record, local_index):
		return "reg" + str(local_index)

	def _emit_arg(self, record, arg_index):
		return "arg" + str(arg_index)
	
	def _emit_string_constant(self, record, value):
		return "__string_constants[" + str(value) + "]"
	def _emit_int_constant(self, record, value):
		return str(value)

	def emit_classes(self):
		def method_prototype(compound, slot):
			record = self.facet.functions[slot.global_function_index]
			result = ""
			if record.has_override:
				result += "virtual "
			if record.returns_value:
				result += "kt_variable "
			else:
				result += "void "
			result += slot.name + "(" + ", ".join( ("kt_variable arg" + str(x) for x in range(record.arg_count) ) ) + ")"
			return result
		def method_body(compound, slot):
			record = self.facet.functions[slot.global_function_index]
			result = ""
			if record.register_count:
				result += "\t\t\tkt_variable " + ", ".join( ("reg" + str(x) for x in range(record.register_count)) ) + ";\n"
			for i in range(len(record.statements)):
				if i in record.branch_targets:
					result += "label" + str(record.branch_targets[i]) + ":\n"
				result += self.emit_statement(record, i)
			return result
			
		decl_str = ""
		for compound in self.facet.sorted_compounds:
			decl_str += "\tstruct " + compound.c_name()
			if compound.parent_node is not None:
				decl_str += " : " + compound.parent_node.c_name()
			decl_str += "\n\t{\n"
			for slot in compound.compound_record.members.values():
				if slot.initial_node == compound:
					if slot.type == 'variable':
						decl_str += "\t\tkt_variable " + slot.name + ";\n"
					elif slot.type == 'function':
						decl_str += "\t\t" + method_prototype(compound, slot) + "\n\t\t{\n" + method_body(compound, slot) + "\t\t}\n"
			decl_str += "\t};\n"
		return decl_str
			
	def go(self):
		emit_string = "#include \"standard_library.h\"\n"
		emit_string = emit_string + "kt_string_constant __string_constants[] = {\n"
		for const_index in range(len(self.facet.string_constants)):
			emit_string = emit_string + "\t{ " + str(len(self.facet.string_constants[const_index])) + ", \"" + self.facet.string_constants[const_index] + "\" },\n"
		emit_string = emit_string +"};\nstruct program\n{\n" + self.emit_classes() + "};\n"
		print emit_string
    
		temp_cpp_file = open("temp_file.cpp", "w")
		temp_cpp_file.write(emit_string)    
		temp_cpp_file.close()
		cpp_process = subprocess.Popen(["gcc", "-I", "../standard_library/", "-o", "run_module", "temp_file.cpp"])
		result = cpp_process.communicate()
		print result
		
		return

		for o in (o for o in facet.globals_list if o.type == 'object'):
			if o.constructor_index is not None:
				callable = (vm.function_record_instance(compiled_facet.functions[o.constructor_index]), self.globals[o.global_index])
				self.call_function(callable, ())
				
	def exec_function(self, func_name, args):
		func_node = self.facet.find_node(None, func_name, lambda x: x.type =='function' )
		self.call_function(self.globals[func_node.global_index].eval(self), ())
	
	def invoke_function_record(self, function_record, reference_object, arguments):
		new_frame = vm.frame(function_record, arguments, self.tos, reference_object)
		self.tos = new_frame
		result = self.exec_current_instruction()
		while result == Exec_Normal:
			result = self.exec_current_instruction()
		self.tos = self.tos.prev_frame
		return result
	
	def call_function(self, callable, arguments):
		callable[0].call(self, callable[1], arguments)

	def exec_current_instruction(self):
		instruction = self.tos.function_record.statements[self.tos.ip]
		spew("Executing instruction: " + str(instruction))
		return self.exec_table[instruction[0]](self, *instruction[1:])
		
	def _exec_eval(self, expression):
		self.eval(expression)
		self.tos.ip += 1
		return Exec_Normal
	
	def _exec_branch_if_zero(self, branch_target, test_expression):
		test_result = self.eval(test_expression)
		if(test_result == 0 or test_result == '\0'):
			self.tos.ip = branch_target
		else:
			self.tos.ip += 1
		return Exec_Normal
	
	def _exec_branch_if_nonzero(self, branch_target, test_expression):
		if(self.eval(test_expression) != 0):
			self.tos.ip = branch_target
		else:
			self.tos.ip += 1
		return Exec_Normal
	
	def _exec_branch_always(self, branch_target):
		self.tos.ip = branch_target
		return Exec_Normal
	
	def _exec_return(self, expression_list):
		list_len = len(expression_list)
		if list_len == 0:
			self.return_value = None
		elif list_len == 1:
			self.return_value = self.eval(expression_list[0])
		else:
			self.return_value = [self.eval(x) for x in expression_list]
		return Exec_Return
	
	def eval(self, node):
		spew("  " * self.depth + "evaluating node: " + str(node))
		self.depth = self.depth + 1
		return_value = self.eval_table[node[0]](self, *node[1:])
		self.depth = self.depth - 1
		spew("  " * self.depth + "returned " + str(return_value))
		return return_value
	def eval_lvalue(self, node):
		return self.evallvalue_table[node[0]](self, *node[1:])
	def store(self, location, value):
		location[0][location[1]] = value

	def _eval_assign(self, left, right):
		self.store(self.eval_lvalue(left), self.eval(right))
	def _eval_float_assign(self, op, left, right):
		loc = self.eval_lvalue(left)
		
		index = loc[1]
		address = loc[0]
		if op == 'add':
			address[index] = address[index] + self.eval(right)
		elif op == 'subtract':
			address[index] = address[index] - self.eval(right)
		elif op == 'multiply':
			address[index] = address[index] * self.eval(right)
		elif op == 'divide':
			address[index] = address[index] / self.eval(right)
		elif op == 'modulus':
			address[index] = address[index] % self.eval(right)

	#bool_binary
	#   op
	#	   "compare_less"
	#	   "compare_greater"
	#	   "compare_less_or_equal"
	#	   "compare_greater_or_equal"
	#	   "compare_equal"
	#	   "compare_not_equal"
	#	   "logical_and"
	#	   "logical_or"
	#   left
	#   right
	def _eval_bool_binary(self, op, left, right):
		left_value = self.eval(left)
		right_value = self.eval(right)
		if op == "compare_less":
			return left_value < right_value
		elif op == "compare_greater":
			return left_value > right_value
		elif op == "compare_less_or_equal":
			return left_value <= right_value
		elif op == "compare_greater_or_equal":
			return left_value >= right_value
		elif op == "compare_equal":
			return left_value == right_value
		elif op == "compare_not_equal":
			return left_value != right_value
		elif op == "logical_and":
			return left_value and right_value
		elif op == "logical_or":
			return left_value or right_value
		raise fatal_error(self, "invalid bool_binary comparison op")

	def _eval_float_binary(self, op, left, right):
		if op == "add":
			spew("left: " + str(left))
			spew("right: " + str(right))
			return self.eval(left) + self.eval(right)
		elif op == "subtract":
			return self.eval(left) - self.eval(right)
		elif op == "multiply":
			return self.eval(left) * self.eval(right)
		elif op == "divide":
			return self.eval(left) / self.eval(right)
		elif op == "modulus":
			return self.eval(left) % self.eval(right)
	def _eval_local(self, local_index):
		return self.tos.registers[local_index]
	def _eval_arg(self, arg_index):
		return self.tos.arguments[arg_index]
	def _evallvalue_local(self, local_index):
		return (self.tos.registers, local_index)
	def _evallvalue_ivar(self, ivar_index):
		return (self.tos.reference_object.slots, ivar_index)
	def _eval_prev_scope(self, prev_scope_node):
		save_top = self.tos
		self.tos = self.tos.reference_object
		result = self.eval(prev_scope_node)
		self.tos = save_top
		return result
	def _eval_global_node(self, node):
		return self.globals[node.global_index].eval(self)
	def _eval_sub_function(self, sub_function_index):
		# callables are (function_record, reference_object) pairs
		return (vm.function_record_instance(self.facet.functions[sub_function_index]), self.tos)
	def _eval_string_constant(self, value):
		return value
	def _eval_int_constant(self, value):
		return value
	def _eval_strcat(self, op_str, left, right):
		spew("strcat " + str(left) + " " + str(right))
		return str(self.eval(left)) + op_str + str(self.eval(right))
	def _eval_func_call(self, func_expr, args):
		callable = self.eval(func_expr)
		evaluated_args = [self.eval(arg) for arg in args]
		self.call_function(callable, evaluated_args)
		return self.return_value
	def _eval_array_index(self, array_expr, index_expr):
		the_array = self.eval(array_expr)
		the_index = self.eval(index_expr)
		
		spew("  " * (self.depth + 1) + str(the_array) + " [ " + str(the_index) + " ] ")
		array_type = type(the_array)
		if array_type == types.ListType or array_type == types.DictType:
			return the_array[the_index]
		if array_type == types.StringType:
			if the_index >= len(the_array):
				return '\0'
			return the_array[the_index]
		pass
	def _eval_imethod(self, imethod_index):
		reference_object = self.tos.reference_object
		method = reference_object.id.vtable[imethod_index]
		spew("imethod: " + str(reference_object))
		return (vm.function_record_instance(method), reference_object) 
	def _eval_selfmethod_global(self, global_index):
		reference_object = self.tos.reference_object
		method = self.facet.functions[global_index]
		return (vm.function_record_instance(method), reference_object)
	def _eval_ivar(self, ivar_index):
 		return self.tos.reference_object.slots[ivar_index]

	#slot_expr
	#   object_expr
	#   slot_name
	def _eval_slot(self, object_expr, slot_name):
		the_object = self.eval(object_expr)
		the_slot = the_object.id.members[slot_name]
 		if the_slot.type == 'variable':
 			return the_object.slots[the_slot.index]
  		elif the_slot.type == 'function':
  			return (vm.function_record_instance(the_object.id.vtable[the_slot.index]), the_object)
	
   	#conditional_expr
   	#   test_expression
   	#   true_expression
   	#   false_expression
   	# ('conditional', test_expr, true_expr, false_expr)
   	def _eval_conditional(self, test_expr, true_expr, false_expr):
		value = self.eval(test_expr)
		if value != 0:
			return self.eval(true_expr)
		else:
			return self.eval(false_expr)
 
 	#array_expr
 	#   array_values
 	# ('array', [array_values])
 	def _eval_array(self, array_values_list):
 		result = []
 		for expr in array_values_list:
 			sub_result = self.eval(expr)
 			result.append(sub_result)
 		return result

	#map_expr
	#   map_pairs
	#	   map_pair
	#		   key
	#		   value
	def _eval_map(self, map_pairs_list):
		result = {}
		for pair in map_pairs_list:
			key = self.eval(pair[0])
			value = self.eval(pair[1])
			result[key] = value
		return result

	#('prev_scope', ()) - a reference to a variable in a previous scope
	#('local', local_index) - local variable
	#('arg', arg_index) - local argument
	#('sub_function', sub_function index)
	#('ivar', slot_index)
	#('imethod', vtable_index)
	#('global_node', global_node_index)
	#('int_constant', value)
	#('float_constant', value)
	#('string_constant', value)
	#('array_index', array_expr, index_expr)
	#('func_call_expr', func_expr, arg_1_expr, ... arg_n_expr)
	#('slot_expr', object_expr, slot_name)
	#locator_expr
	#   string
	#int_constant_expr
	#   value
	#float_constant_expr
	#   value
	#string_constant
	#   value
	#array_index_expr
	#   array_expr
	#   index_expr
	#func_call_expr
	#   func_expr
	#   args
	#unary_lvalue_op_expr
	#   expression
	#   op
	#	   "post_increment"
	#	   "post_decrement"
	#	   "pre_increment"
	#	   "pre_decrement"
	#unary_minus_expr
	#   expression
	#logical_not_expr
	#   expression
	#bitwise_not_expr
	#   expression
	#float_binary_expr
	#   left
	#   right
	#   op
	#	   "multiply"
	#	   "divide"
	#	   "modulus"
	#	   "add"
	#	   "subtract"
	#int_binary_expr
	#   left
	#   right
	#   op
	#	   "shift_left"
	#	   "shift_right"
	#	   "bitwise_and"
	#	   "bitwise_xor"
	#	   "bitwise_or"
	#bool_binary_expr
	#   left
	#   right
	#   op
	#	   "compare_less"
	#	   "compare_greater"
	#	   "compare_less_or_equal"
	#	   "compare_greater_or_equal"
	#	   "compare_equal"
	#	   "compare_not_equal"
	#	   "logical_and"
	#	   "logical_or"
	#strcat_expr
	#   left
	#   right
	#   op
	#	   "cat_none"
	#	   "cat_newline"
	#	   "cat_space"
	#	   "cat_tab"
	#assign_expr
	#   left
	#   right
	#float_assign_expr
	#   left
	#   right
	#   op
	#int_assign_expr
	#   left
	#   right
	#   op
	#function_expr
	#   parameter_list
	#   expr
